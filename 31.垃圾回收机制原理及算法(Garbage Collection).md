<font size = 4 face = "黑体">

java引入了垃圾回收机制，令C++程序员最头疼的内存管理问题迎刃而解。Java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高了开发效率。

#### 垃圾回收原理和算法

</br></br></br>

- 内存管理

　　Java的内存管理很大程度指的就是对象的管理，其中包括对象空间的分配和释放。

　　对象空间的分配：使用new关键字创建对象即可

　　对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有”不可达”对象的内存空间。



</br></br></br>

- 垃圾回收过程

　　任何一种垃圾回收算法一般要做两件基本事情：

　　1. 发现无用的对象

　　2. 回收无用对象占用的内存空间。

　　垃圾回收机制保证可以将“无用的对象”进行回收。无用的对象指的就是没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。






</br></br></br>

- 垃圾回收相关算法

1. 引用计数法

　　堆中每个对象都有一个引用计数。被引用一次，计数加1. 被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是“循环引用的无用对象”无法别识别。

【示例】循环引用示例　　

public class Student {
    String name;
    Student friend;
     
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student();
         
        s1.friend = s2;
        s2.friend = s1;        
        s1 = null;
        s2 = null;
    }
}
　　s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。

2. 引用可达法(根搜索算法)

　　程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。
















</br></br></br></br></br></br>

#### 通用的分代垃圾回收机制


分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。

　　1. 年轻代

　　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。

　　2. 年老代

　　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。

　　3. 持久代

　　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

![堆内存的划分细节](https://img-blog.csdnimg.cn/20200119203606152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODA4NzAw,size_16,color_FFFFFF,t_70)


　　·Minor GC:

　　用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)

　　·Major GC：

　　用于清理老年代区域。

　　·Full GC：

　　用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。

垃圾回收过程：

1、新创建的对象，绝大多数都会存储在Eden中，

2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，

然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区

3、当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，

同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。

4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，

5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）














</br></br></br></br></br></br>

#### JVM调优和Full GC



　　在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：

1.年老代(Tenured)被写满

2.持久代(Perm)被写满

3.System.gc()被显式调用（**程序建议GC启动，不是调用GC**）

4.上一次GC之后Heap的各域分配策略动态变化





</font>